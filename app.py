# -*- coding: utf-8 -*-
"""Pricing Recommendation Tool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vEY1vNNaYw_xKZGJ_F2Qlc5EqPwhJ1I7
"""

import numpy as np
import pandas as pd

pricing = pd.read_csv("/content/drive/MyDrive/Pricing_Data_CLEAN.csv")
ads = pd.read_csv("/content/drive/MyDrive/Cleaned_Ads_Data.csv")
competitor = pd.read_csv("/content/drive/MyDrive/clean_competitor_data.csv")
inventory = pd.read_csv("/content/drive/MyDrive/clean_Inventory_data.csv")
returns = pd.read_csv("/content/drive/MyDrive/clean_Returns_data.csv")
HSales = pd.read_csv ('/content/drive/MyDrive/HSales.csv')
df = pd.read_csv("/content/drive/MyDrive/merged_pricing_dataset.csv")

df.head()

df.columns


# This cell is no longer needed as app.py now loads data directly.
# import pandas as pd
# import streamlit as st
# st.session_state["df"] = df

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# 
# # ======================
# # LOAD DATA
# # ======================
# @st.cache_data
# def load_data():
#     try:
#         df = pd.read_csv("/content/drive/MyDrive/merged_pricing_dataset.csv")
#     except:
#         uploaded = st.file_uploader("Upload Pricing Dataset CSV", type="csv")
#         if uploaded:
#             df = pd.read_csv(uploaded)
#         else:
#             st.stop()
#     return df
# 
# 
# df = load_data()
# 
# st.set_page_config(page_title="Pricing Recommendation Engine", layout="wide")
# 
# st.title("üì¶ Pricing Recommendation & Decision Support Tool")
# 
# # ======================
# # SKU SELECTOR
# # ======================
# sku = st.selectbox("Select SKU", sorted(df["SKU"].unique()))
# sku_df = df[df["SKU"] == sku].copy()
# 
# # Use latest record
# row = sku_df.sort_values("Date").iloc[-1]
# 
# # ======================
# # COST MODEL
# # ======================
# total_cost = (
#     row["Cost"]
#     + row.get("FBA_Fee", 0)
#     + row.get("Storage_Fee", 0)
#     + row.get("Handling_Cost", 0)
# )
# 
# min_margin = row["Minimum_Acceptable_Margin_%"] / 100
# target_margin = row["Target_Gross_Margin_%"] / 100
# 
# current_price = row["Current_Price"]
# 
# current_margin = (current_price - total_cost) / current_price if current_price else 0
# 
# days_supply = row.get("days_of_supply", np.nan)
# 
# competitor_avg = row.get("Avg_Competitor_Price", np.nan)
# competitor_low = row.get("Lowest_Competitor_Price", np.nan)
# competitor_high = row.get("Highest_Competitor_Price", np.nan)
# 
# units90 = row.get("units_shipped_t90", 0)
# returns90 = row.get("returns_t90", 0)
# 
# return_risk_load = (returns90 / (units90 + 1)) * total_cost
# 
# ads_acos = row.get("acosClicks14d", np.nan)
# 
# # ======================
# # PRICE TARGETS
# # ======================
# min_price_allowed = total_cost / (1 - min_margin)
# target_price = total_cost / (1 - target_margin)
# 
# # ======================
# # INVENTORY SIGNAL
# # ======================
# if pd.isna(days_supply):
#     inventory_signal = 0
# elif days_supply < 20:
#     inventory_signal = +0.05   # raise price 5%
# elif days_supply > 90:
#     inventory_signal = -0.05   # discount 5%
# else:
#     inventory_signal = 0
# 
# # ======================
# # COMPETITOR SIGNAL
# # ======================
# if not pd.isna(competitor_avg):
#     competitor_target = 0.7 * competitor_avg + 0.3 * current_price
# else:
#     competitor_target = current_price
# 
# # ======================
# # ADS SIGNAL
# # ======================
# if pd.isna(ads_acos):
#     ads_signal = 0
# elif ads_acos > 40:
#     ads_signal = +0.05
# elif ads_acos < 20:
#     ads_signal = -0.05
# else:
#     ads_signal = 0
# 
# # ======================
# # RETURN RISK SIGNAL
# # ======================
# if return_risk_load > 0.2 * total_cost:
#     risk_signal = +0.05
# else:
#     risk_signal = 0
# 
# # ======================
# # BASE PRICE
# # ======================
# base = max(target_price, min_price_allowed)
# 
# # ======================
# # APPLY SIGNALS
# # ======================
# recommended_price = base
# recommended_price *= (1 + inventory_signal)
# recommended_price *= (1 + ads_signal)
# recommended_price *= (1 + risk_signal)
# 
# # blend with competitor
# recommended_price = 0.6 * recommended_price + 0.4 * competitor_target
# 
# # enforce minimum
# recommended_price = max(recommended_price, min_price_allowed)
# 
# recommended_margin = (recommended_price - total_cost) / recommended_price
# 
# # ======================
# # RISK LABEL
# # ======================
# risk_level = "LOW"
# if return_risk_load > 0.2 * total_cost or ads_acos > 40:
#     risk_level = "HIGH"
# elif days_supply and days_supply < 20:
#     risk_level = "MEDIUM"
# 
# 
# # ======================
# # KPI CARDS
# # ======================
# col1, col2, col3, col4 = st.columns(4)
# 
# col1.metric("üí≤ Current Price", f"${current_price:,.2f}")
# col2.metric("üì¶ Days of Supply", f"{days_supply:.0f}" if not pd.isna(days_supply) else "N/A")
# col3.metric("üìâ Current Gross Margin", f"{current_margin*100:.1f}%")
# col4.metric("‚ö† Risk Level", risk_level)
# 
# col5, col6, col7, col8 = st.columns(4)
# col5.metric("üßÆ Total Cost", f"${total_cost:,.2f}")
# col6.metric("‚úî Min Margin", f"{min_margin*100:.1f}%")
# col7.metric("üéØ Target Margin", f"{target_margin*100:.1f}%")
# col8.metric("üîÆ Recommended Price", f"${recommended_price:,.2f}")
# 
# st.caption(
# """
# **Total Cost Includes:** Product Cost + FBA Fee + Storage Fee + Handling Cost
# """
# )
# 
# # ======================
# # EXPLANATION
# # ======================
# st.subheader("üß† Price Recommendation Rationale")
# 
# reason = []
# 
# if inventory_signal > 0:
#     reason.append("Low inventory ‚ûú price increased slightly")
# elif inventory_signal < 0:
#     reason.append("High inventory ‚ûú price reduced slightly")
# 
# if ads_signal > 0:
#     reason.append("High ACOS ‚ûú price increased to protect margin")
# elif ads_signal < 0:
#     reason.append("Efficient ads ‚ûú price optimized for volume")
# 
# if risk_signal > 0:
#     reason.append("High returns ‚ûú price adjusted for risk")
# 
# if not pd.isna(competitor_avg):
#     reason.append("Price aligned with competitor market")
# 
# if len(reason)==0:
#     reason.append("Price optimized to reach target margin safely")
# 
# for r in reason:
#     st.write("‚Ä¢", r)
# 
# st.success(f"üìå Final Price ensures **‚â• Minimum Margin** and aims for **Target Margin** while balancing demand, ads & risk.")
# 
# 
# # ======================
# # SALES TREND
# # ======================
# st.subheader("üìà Historical Sales Trend")
# sales_df = sku_df.groupby("Date")["Units Ordered"].sum().reset_index()
# fig = px.area(sales_df, x="Date", y="Units Ordered")
# st.plotly_chart(fig, use_container_width=True)
# 
# # ======================
# # COMPETITOR TREND
# # ======================
# st.subheader("üè∑ Price vs Competitors")
# comp_df = sku_df[["Date","Current_Price","Avg_Competitor_Price"]]
# fig2 = px.line(comp_df, x="Date", y=["Current_Price","Avg_Competitor_Price"])
# st.plotly_chart(fig2, use_container_width=True)
# 
# # ======================
# # ADS PERFORMANCE
# # ======================
# st.subheader("üì¢ Ads Performance (ROAS & ACOS)")
# ads_df = sku_df[["Date","acosClicks14d","roasClicks14d"]]
# fig3 = px.line(ads_df, x="Date", y=["acosClicks14d","roasClicks14d"])
# st.plotly_chart(fig3, use_container_width=True)
#

